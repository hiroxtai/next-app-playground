# GitHub Copilot エージェント ガイド

このドキュメントでは、本プロジェクトで利用可能な GitHub Copilot カスタムエージェントの一覧、使い方、使い分け方を解説します。学習者向けに分かりやすくまとめています。

**最終更新**: 2025年7月

> **📊 ファイル数**: 現在 **42** 個のカスタムエージェントが利用可能です。

---

## 📖 目次

1. [エージェントとは](#エージェントとは)
2. [エージェントの使い方](#エージェントの使い方)
3. [カテゴリ別エージェント一覧](#カテゴリ別エージェント一覧)
   - [🚀 開発 & 実装](#-開発--実装)
   - [📋 計画 & 設計](#-計画--設計)
   - [🧪 テスト & 品質](#-テスト--品質)
   - [🔐 セキュリティ & レビュー](#-セキュリティ--レビュー)
   - [📚 ドキュメント & 学習](#-ドキュメント--学習)
   - [🛠️ DevOps & インフラ](#️-devops--インフラ)
   - [💡 アイデア & ブレスト](#-アイデア--ブレスト)
   - [🧹 リファクタリング & 改善](#-リファクタリング--改善)
   - [🎓 メンタリング & 教育](#-メンタリング--教育)
4. [似たエージェントの使い分け](#似たエージェントの使い分け)
5. [このプロジェクトでの推奨フロー](#このプロジェクトでの推奨フロー)
6. [🌟 高度なワークフロー・ベストプラクティス](#-高度なワークフローベストプラクティス)
7. [エージェント詳細リファレンス](#エージェント詳細リファレンス)

---

## エージェントとは

エージェントは、特定の役割や専門知識を持つ AI アシスタントの「ペルソナ」です。各エージェントは異なる専門分野に特化しており、適切なエージェントを選ぶことで、より質の高い支援を受けることができます。

### エージェントの特徴

| 特徴 | 説明 |
|------|------|
| **専門性** | 各エージェントは特定の分野（セキュリティ、テスト、設計など）に特化 |
| **ツール** | エージェントごとに利用可能なツールが異なる（コード編集、検索、テスト実行など） |
| **スタイル** | 応答のスタイルやトーンがエージェントごとに異なる |
| **制約** | 一部のエージェントはコード編集を行わないなど、意図的な制約がある |

---

## エージェントの使い方

### VS Code での呼び出し方

```
@agent-name プロンプト
```

例:
```
@expert-nextjs-developer Server Componentでデータフェッチを行うページを作成して
@wg-code-sentinel このコードのセキュリティをレビューして
@plan 新機能の実装計画を立てて
```

### Copilot Chat での選択

1. Copilot Chat を開く（`Cmd+Shift+I` または `Ctrl+Shift+I`）
2. エージェント選択ドロップダウンから目的のエージェントを選択
3. プロンプトを入力

---

## カテゴリ別エージェント一覧

### 🚀 開発 & 実装

実際にコードを書いたり、機能を実装したりするエージェント。

| エージェント名 | 概要 | 主な用途 |
|--------------|------|---------|
| **expert-nextjs-developer** | Next.js 16 のエキスパート | App Router、Server Components、Cache Components の実装 |
| **blueprint-mode** | 構造化ワークフローで開発 | 複雑なタスクの段階的な実装、厳密な品質管理 |
| **playwright-tester** | Playwright テスト専門家 | E2E テストの作成・保守 |
| **address-comments** | PR コメント対応 | プルリクエストのレビューコメントへの対応 |

---

### 📋 計画 & 設計

実装前の計画、設計、アーキテクチャ検討を行うエージェント。**コード編集は行わない**。

| エージェント名 | 概要 | 主な用途 |
|--------------|------|---------|
| **plan** | 戦略的計画アシスタント | コードベース理解、要件整理、実装戦略の策定 |
| **planner** | 実装計画生成 | シンプルな実装計画ドキュメントの作成 |
| **implementation-plan** | 詳細な実装計画 | AI・人間が実行可能な詳細計画の生成 |
| **task-planner** | タスク計画作成 | 研究に基づいた実行可能なタスク計画 |
| **task-researcher** | タスク調査専門 | 実装前の深い調査、ドキュメント作成 |
| **specification** | 仕様書生成 | 要件、制約、インターフェースの仕様化 |
| **refine-issue** | Issue 詳細化 | 受け入れ基準、技術考慮、エッジケースの追加 |
| **arch** | クラウドアーキテクト | アーキテクチャ図とドキュメントの作成 |
| **hlbpa** | ハイレベル設計 | システムの高レベル設計・ドキュメント |

---

### 🧪 テスト & 品質

TDD（テスト駆動開発）やテストの作成・実行を支援するエージェント。

| エージェント名 | 概要 | 主な用途 |
|--------------|------|---------|
| **tdd-red** | TDD Red フェーズ | 失敗するテストの作成（要件を定義） |
| **tdd-green** | TDD Green フェーズ | テストを通す最小限のコード作成 |
| **tdd-refactor** | TDD Refactor フェーズ | テストを緑に保ちながらリファクタリング |
| **playwright-tester** | E2E テスト専門 | Playwright でのブラウザテスト作成 |

---

### 🔐 セキュリティ & レビュー

コードのセキュリティ、品質、設計をレビューするエージェント。

| エージェント名 | 概要 | 主な用途 |
|--------------|------|---------|
| **wg-code-sentinel** | セキュリティレビュー | OWASP Top 10、脆弱性の検出と修正提案 |
| **se-security-reviewer** | エンタープライズセキュリティ | Zero Trust、LLM セキュリティ、詳細なレビュー |
| **wg-code-alchemist** | Clean Code レビュー | SOLID 原則、Clean Code へのリファクタリング |
| **gilfoyle** | 辛辣なコードレビュー | 遠慮のない、しかし的確な技術的批評 |
| **accessibility** | アクセシビリティ監査 | WCAG 2.2 準拠、ARIA パターン、スクリーンリーダー対応 |
| **se-responsible-ai** | 責任ある AI | バイアス防止、プライバシー、倫理的 AI 開発 |

---

### 📚 ドキュメント & 学習

ドキュメント作成、学習支援を行うエージェント。

| エージェント名 | 概要 | 主な用途 |
|--------------|------|---------|
| **context7** | ライブラリドキュメント取得 | 最新のライブラリドキュメントの取得 |
| **se-technical-writer** | テクニカルライター | 開発者ドキュメント、ブログ、チュートリアル作成 |
| **technical-content-evaluator** | 技術コンテンツ評価 | 教育資料の品質評価と改善提案 |

---

### 🛠️ DevOps & インフラ

CI/CD、デプロイメント、インフラ管理を支援するエージェント。

| エージェント名 | 概要 | 主な用途 |
|--------------|------|---------|
| **devops-expert** | DevOps エキスパート | CI/CD パイプライン、デプロイ戦略の設計 |
| **github-actions-expert** | GitHub Actions 専門 | セキュアなワークフロー、アクションのピン留め |
| **se-gitops-ci-specialist** | GitOps/CI 専門 | デプロイ障害のトラブルシューティング |
| **se-system-architecture-reviewer** | システムアーキテクチャ | Well-Architected フレームワーク、スケーラビリティ分析 |

---

### 💡 アイデア & ブレスト

新しいアイデアの発想、要件の整理を支援するエージェント。

| エージェント名 | 概要 | 主な用途 |
|--------------|------|---------|
| **simple-app-idea-generator** | アプリアイデア生成 | 楽しいブレインストーミングでアイデア創出 |
| **se-product-manager-advisor** | プロダクトマネージャー | GitHub Issue 作成、ユーザーニーズの分析 |
| **se-ux-ui-designer** | UX/UI デザイナー | Jobs-to-be-Done 分析、ユーザージャーニーマップ |

---

### 🧹 リファクタリング & 改善

既存コードの改善、技術的負債の解消を支援するエージェント。

| エージェント名 | 概要 | 主な用途 |
|--------------|------|---------|
| **janitor** | コードクリーンアップ | 不要コード削除、シンプル化、依存関係整理 |
| **tech-debt-remediation-plan** | 技術的負債対策 | 技術的負債の分析と改善計画の作成 |
| **modernization** | モダナイゼーション | レガシープロジェクトの分析と近代化計画 |

---

### 🎓 メンタリング & 教育

学習支援、思考の深化を促すエージェント。**コード編集は行わない**。

| エージェント名 | 概要 | 主な用途 |
|--------------|------|---------|
| **mentor** | メンター | ソクラテス式の質問で思考を深める |
| **critical-thinking** | 批判的思考促進 | 「なぜ？」を問い続け、前提を検証 |
| **demonstrate-understanding** | 理解度確認 | 実装への理解度を質問で検証 |

---

### 🔧 ユーティリティ

その他の便利なエージェント。

| エージェント名 | 概要 | 主な用途 |
|--------------|------|---------|
| **prompt-engineer** | プロンプト改善 | AI プロンプトの分析と最適化 |
| **prompt-builder** | プロンプト構築 | 高品質なプロンプトの作成とテスト |
| **custom-agent-foundry** | エージェント作成 | 新しいカスタムエージェントの設計・作成 |

---

## 似たエージェントの使い分け

### 📋 計画系エージェントの使い分け

```
┌─────────────────────────────────────────────────────────────────┐
│                    計画系エージェント選択フロー                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  「何を作るか決まっている？」                                      │
│         │                                                       │
│    ┌────┴────┐                                                  │
│   いいえ     はい                                                │
│    │         │                                                  │
│    ▼         ▼                                                  │
│  plan    「詳細な調査が必要？」                                    │
│  (戦略的    │                                                   │
│   分析)  ┌──┴──┐                                                │
│        いいえ  はい                                              │
│         │      │                                                │
│         ▼      ▼                                                │
│      planner  task-researcher                                   │
│      (簡易   （深い調査）                                         │
│       計画)      │                                              │
│                 ▼                                               │
│            task-planner                                         │
│            (実行可能な計画)                                       │
│                 │                                               │
│                 ▼                                               │
│         implementation-plan                                     │
│         (AI実行可能な詳細計画)                                    │
└─────────────────────────────────────────────────────────────────┘
```

| エージェント | 使うタイミング | 出力 |
|------------|--------------|------|
| **plan** | コードベースを理解してから計画を立てたい | 実装戦略、アーキテクチャ提案 |
| **planner** | シンプルに実装計画が欲しい | 概要、要件、ステップ、テスト項目 |
| **task-researcher** | 実装前に徹底的に調査したい | 調査レポート（`.copilot-tracking/research/`） |
| **task-planner** | 調査に基づいた実行計画が欲しい | チェックリスト、詳細、プロンプト |
| **implementation-plan** | AI や他の人が実行可能な計画が欲しい | 構造化された実装計画書 |

---

### � task-planner → 実装 の詳細ワークフロー

task-planner と task-researcher を使った本格的な計画・実装フローの詳細です。

#### task-planner が生成するファイル

task-planner は**3つのファイル**を自動生成します：

| ファイル | 配置場所 | 内容 |
|---------|---------|------|
| **Plan** | `.copilot-tracking/plans/YYYYMMDD-task-description-plan.instructions.md` | フェーズとタスクのチェックリスト |
| **Details** | `.copilot-tracking/details/YYYYMMDD-task-description-details.md` | 各タスクの詳細な実装仕様 |
| **Implementation Prompt** | `.copilot-tracking/prompts/implement-task-description.prompt.md` | 実装を実行するためのプロンプト |

#### 計画から実装までのフロー

```
┌─────────────────────────────────────────────────────────────────┐
│           task-planner → 実装 の完全ワークフロー                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1️⃣ 調査フェーズ（必要な場合）                                    │
│     @task-researcher 〇〇機能について調査して                     │
│     └── .copilot-tracking/research/ に調査レポートが生成          │
│                                                                 │
│  2️⃣ 計画フェーズ                                                 │
│     @task-planner 〇〇機能を実装したい                           │
│     └── plans/, details/, prompts/ に3ファイルが生成            │
│                                                                 │
│  3️⃣ 計画のレビュー                                               │
│     └── .copilot-tracking/plans/*-plan.instructions.md を確認    │
│         └── 問題があれば @task-planner で修正                    │
│                                                                 │
│  4️⃣ ⚠️ 新しいチャットを開始                                      │
│     └── Agent モードに切り替え                                   │
│                                                                 │
│  5️⃣ 実装プロンプトを実行                                         │
│     #file:.copilot-tracking/prompts/implement-*.prompt.md       │
│                                                                 │
│  6️⃣ 各フェーズで停止（phaseStop=true の場合）                     │
│     ├── 変更内容をレビュー                                       │
│     ├── テスト実行                                               │
│     └── 「続けてください」で次のフェーズへ                         │
│                                                                 │
│  7️⃣ 完了後                                                       │
│     ├── .copilot-tracking/changes/ で変更履歴を確認              │
│     └── 不要なファイルを削除またはアーカイブ                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 実装時の制御オプション

| オプション | 値 | 説明 |
|-----------|------|------|
| `phaseStop` | `true`（デフォルト） | 各フェーズ完了後に停止してレビュー可能 |
| `phaseStop` | `false` | 全フェーズを一気に実装 |
| `taskStop` | `true` | 各タスク完了後に停止（より細かい制御） |
| `taskStop` | `false`（デフォルト） | タスクごとに停止しない |

#### 実践例

```bash
# Step 1: 調査（オプション）
@task-researcher Next.js 16 の Server Actions について調査して

# Step 2: 計画作成
@task-planner カタログページに検索フィルター機能を追加したい

# Step 3: 生成されたファイルを確認
# .copilot-tracking/
# ├── research/20260115-search-filter-research.md
# ├── plans/20260115-search-filter-plan.instructions.md
# ├── details/20260115-search-filter-details.md
# └── prompts/implement-search-filter.prompt.md

# Step 4: 新しいチャットで Agent モードに切り替え
# Step 5: 実装プロンプトを実行
#file:.copilot-tracking/prompts/implement-search-filter.prompt.md

# Step 6: フェーズ完了後の対応
# → 問題なければ「続けてください」
# → 変更が必要なら「Phase 2 の Task 2.1 を〇〇に変更して続けてください」
```

#### ⚠️ 重要なポイント

1. **必ず新しいチャットを開始**
   - 計画作成時と実装時のコンテキストを分離することで、より正確な実装が可能

2. **Changes ファイルの自動追跡**
   - 実装中は `.copilot-tracking/changes/` に変更履歴が自動記録される
   - リリースノートやドキュメント更新に活用可能

3. **計画の修正が必要な場合**
   - 実装前に `@task-planner` で計画を修正
   - 実装中に問題が発生した場合は、Changes ファイルに「計画外の変更」として記録

4. **VS Code 設定の追加（推奨）**
   ```json
   // .vscode/settings.json
   {
     "chat.instructionsFilesLocations": {
       ".copilot-tracking/plans": true,
       ".copilot-tracking/details": true,
       ".github/instructions": true
     }
   }
   ```

---

### �🔐 セキュリティ系エージェントの使い分け

```
┌─────────────────────────────────────────────────────────────────┐
│                 セキュリティ系エージェント選択                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  「どのレベルのレビューが必要？」                                   │
│         │                                                       │
│    ┌────┴────┬─────────┐                                        │
│  基本的   詳細な    AI/LLM                                       │
│    │       │        │                                          │
│    ▼       ▼        ▼                                          │
│  wg-code  se-      se-                                          │
│  sentinel security responsible                                  │
│           reviewer -ai                                          │
│                                                                 │
│  ・OWASP   ・Zero   ・バイアス                                    │
│   Top 10    Trust   ・プライバシー                                │
│  ・基本的   ・LLM    ・倫理的AI                                   │
│   脆弱性    セキュリ                                              │
│            ティ                                                 │
└─────────────────────────────────────────────────────────────────┘
```

| エージェント | 使うタイミング | フォーカス |
|------------|--------------|----------|
| **wg-code-sentinel** | 一般的なセキュリティレビュー | OWASP Top 10、基本的な脆弱性 |
| **se-security-reviewer** | エンタープライズレベルのレビュー | Zero Trust、LLM セキュリティ、詳細な分析 |
| **se-responsible-ai** | AI/ML システムのレビュー | バイアス、プライバシー、倫理的考慮 |

---

### 🧹 コード改善系エージェントの使い分け

| エージェント | 使うタイミング | アプローチ |
|------------|--------------|----------|
| **wg-code-alchemist** | 設計を改善したい | SOLID 原則、Clean Code、丁寧な説明 |
| **janitor** | 不要なコードを削除したい | 「引き算」で価値を生む、依存関係整理 |
| **tech-debt-remediation-plan** | 技術的負債を計画的に解消したい | 分析と計画のみ、優先順位付け |
| **gilfoyle** | 遠慮なく問題を指摘してほしい | 辛辣だが的確なレビュー、解決策は教えない |

---

### 🧪 TDD エージェントの使い分け

TDD の 3 フェーズに対応したエージェント群です。**順番に使用**します。

```
┌─────────────────────────────────────────────────────────────────┐
│                      TDD サイクル                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│    ┌──────────┐      ┌──────────┐      ┌──────────┐           │
│    │  RED     │ ───► │  GREEN   │ ───► │ REFACTOR │           │
│    │ (失敗)   │      │ (成功)   │      │ (改善)   │           │
│    └──────────┘      └──────────┘      └──────────┘           │
│         │                 │                 │                  │
│         ▼                 ▼                 ▼                  │
│    tdd-red           tdd-green         tdd-refactor            │
│    ・テスト作成      ・最小限の        ・テストを緑に            │
│    ・要件を定義       実装              保ちながら              │
│    ・失敗を確認      ・ハードコード     ・設計改善               │
│                       も OK                                    │
└─────────────────────────────────────────────────────────────────┘
```

1. **tdd-red**: 要件を失敗するテストとして表現
2. **tdd-green**: テストを通す最小限のコードを書く
3. **tdd-refactor**: テストを緑に保ちながら設計を改善

---

## このプロジェクトでの推奨フロー

### 🎯 新機能開発フロー

```
┌─────────────────────────────────────────────────────────────────┐
│                    新機能開発の推奨フロー                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1️⃣ アイデア・要件整理                                           │
│     ├── simple-app-idea-generator  ← アイデアを膨らませたい      │
│     ├── se-product-manager-advisor ← Issue を作成したい         │
│     └── refine-issue               ← Issue を詳細化したい       │
│                                                                 │
│  2️⃣ 計画・設計                                                   │
│     ├── plan                       ← コードベース理解 + 戦略     │
│     ├── specification              ← 仕様書を作成               │
│     └── arch                       ← アーキテクチャ図を作成      │
│                                                                 │
│  3️⃣ 実装                                                        │
│     ├── expert-nextjs-developer    ← Next.js コードを書く        │
│     ├── blueprint-mode             ← 複雑なタスクを段階的に      │
│     └── context7                   ← ライブラリドキュメント参照   │
│                                                                 │
│  4️⃣ テスト                                                       │
│     ├── tdd-red → tdd-green → tdd-refactor ← TDD サイクル       │
│     └── playwright-tester          ← E2E テストを書く           │
│                                                                 │
│  5️⃣ レビュー                                                     │
│     ├── wg-code-sentinel           ← セキュリティレビュー        │
│     ├── wg-code-alchemist          ← Clean Code レビュー        │
│     └── accessibility              ← アクセシビリティ監査        │
│                                                                 │
│  6️⃣ ドキュメント                                                 │
│     └── se-technical-writer        ← ドキュメント作成           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

### 📝 学習プロジェクトでの活用例

#### シナリオ 1: 新しいコンポーネントを作成する

```bash
# Step 1: 計画を立てる
@plan カタログページに検索フィルター機能を追加したい

# Step 2: 最新のドキュメントを確認
@context7 shadcn/ui の Input コンポーネントの使い方を教えて

# Step 3: 実装する
@expert-nextjs-developer 検索フィルターコンポーネントを作成して

# Step 4: テストを書く（TDD）
@tdd-red SearchFilter コンポーネントのテストを作成して

# Step 5: コードレビュー
@wg-code-alchemist SearchFilter コンポーネントをレビューして

# Step 6: アクセシビリティ確認
@accessibility SearchFilter コンポーネントのアクセシビリティをチェックして
```

#### シナリオ 2: 既存のコードを理解する

```bash
# Step 1: コードの概要を把握
@plan catalog-data.ts の構造と役割を説明して

# Step 2: 理解度を確認
@demonstrate-understanding catalog-data.ts の設計について説明させて

# Step 3: 批判的に検討
@critical-thinking この設計の問題点は？
```

#### シナリオ 3: 技術的負債を解消する

```bash
# Step 1: 負債を分析
@tech-debt-remediation-plan このプロジェクトの技術的負債を分析して

# Step 2: 不要コードを特定
@janitor src/app/catalog の不要なコードを特定して

# Step 3: リファクタリング
@wg-code-alchemist PageCard コンポーネントを Clean Code にリファクタして
```

---

### 🔄 CI/CD での活用例

```bash
# GitHub Actions の改善
@github-actions-expert CI ワークフローのセキュリティを強化したい

# デプロイトラブルシューティング
@se-gitops-ci-specialist デプロイが失敗している。原因を調査して
```

---

## 🌟 高度なワークフロー・ベストプラクティス

awesome-copilot リポジトリの調査に基づいた、より高度で効果的なワークフローを紹介します。

### 🏗️ Spec-Driven Workflow（仕様駆動開発）

**概要**: 要件定義から実装、検証までを構造化されたドキュメントで管理するワークフローです。

```
┌─────────────────────────────────────────────────────────────────┐
│                   Spec-Driven Workflow (6-Phase)                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  📄 常に維持するドキュメント:                                     │
│     • requirements.md - ユーザーストーリーと受け入れ基準         │
│     • design.md - 技術アーキテクチャ、シーケンス図               │
│     • tasks.md - 詳細で追跡可能な実装計画                        │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ Phase 1: ANALYZE                                          │  │
│  │ • 既存コード・ドキュメント・テストを読み込む                │  │
│  │ • 要件を EARS 記法で定義                                   │  │
│  │ • 依存関係と制約を特定                                     │  │
│  │ • 信頼度スコア (0-100%) を算出                             │  │
│  └──────────────────────────────────────────────────────────┘  │
│                          ↓                                      │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ Phase 2: DESIGN                                           │  │
│  │ • 信頼度に応じた戦略を選択:                                │  │
│  │   >85%: 詳細な実装計画                                     │  │
│  │   66-85%: MVP/PoC を先に作成                               │  │
│  │   <66%: 追加調査を実施                                     │  │
│  │ • design.md に技術設計を記録                               │  │
│  │ • tasks.md に実装計画を作成                                │  │
│  └──────────────────────────────────────────────────────────┘  │
│                          ↓                                      │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ Phase 3: IMPLEMENT                                        │  │
│  │ • 小さくテスト可能な単位でコーディング                     │  │
│  │ • 依存関係の順序でボトムアップ実装                         │  │
│  │ • タスクステータスをリアルタイム更新                       │  │
│  └──────────────────────────────────────────────────────────┘  │
│                          ↓                                      │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ Phase 4: VALIDATE                                         │  │
│  │ • 自動テスト実行                                           │  │
│  │ • エッジケースとエラー処理のテスト                         │  │
│  │ • パフォーマンス検証                                       │  │
│  └──────────────────────────────────────────────────────────┘  │
│                          ↓                                      │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ Phase 5: REFLECT                                          │  │
│  │ • 保守性向上のためのリファクタリング                       │  │
│  │ • 全ドキュメントの更新                                     │  │
│  │ • 技術的負債の Issue 自動作成                              │  │
│  └──────────────────────────────────────────────────────────┘  │
│                          ↓                                      │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ Phase 6: HANDOFF                                          │  │
│  │ • エグゼクティブサマリー生成                               │  │
│  │ • プルリクエストの準備                                     │  │
│  │ • ワークスペースの整理                                     │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**EARS 記法の例**（要件定義に使用）:
```
# イベント駆動型
WHEN ユーザーが検索ボタンをクリックする
THE SYSTEM SHALL 入力値に基づいて結果をフィルタリングする

# 状態駆動型
WHILE ローディング状態である間
THE SYSTEM SHALL スケルトンUIを表示する

# 異常系
IF 検索結果が0件の場合
THEN THE SYSTEM SHALL 「結果が見つかりません」メッセージを表示する
```

---

### 🔵 Blueprint Mode（構造化ワークフロー）

**概要**: 4つのワークフロー（Loop, Debug, Express, Main）を自動選択し、厳密な品質管理で実装を行います。

#### ワークフロー選択フロー

```
┌─────────────────────────────────────────────────────────────────┐
│                   Blueprint Mode ワークフロー選択                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  「どの種類のタスク？」                                          │
│         │                                                       │
│    ┌────┴────┬─────────┬─────────┐                             │
│  繰り返し  バグ修正  小規模    それ以外                          │
│    │        │       (≤2ファイル)  │                             │
│    ▼        ▼        ▼           ▼                             │
│  Loop    Debug    Express      Main                             │
│                                                                 │
│  【Loop】                        【Debug】                       │
│  1. 対象アイテムを特定           1. バグを再現                   │
│  2. 各アイテムにワークフロー割当  2. 根本原因を特定               │
│  3. 順次実行・検証               3. 修正を実装                   │
│                                 4. エッジケースをテスト          │
│                                                                 │
│  【Express】                     【Main】                        │
│  1. todos を作成                1. ANALYZE: 要件理解             │
│  2. 変更を適用                  2. DESIGN: アーキテクチャ設計    │
│  3. 検証して完了                3. PLAN: タスク分割              │
│                                 4. IMPLEMENT: 実装               │
│                                 5. VERIFY: 検証                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 自己評価（Self-Reflection）

Blueprint Mode は各タスク完了後に**5つの観点**で自己評価を行います:

| 観点 | 基準 | 合格スコア |
|------|------|----------|
| Correctness | 明示的な要件を満たしているか | > 8 |
| Robustness | エッジケースと不正入力を適切に処理するか | > 8 |
| Simplicity | 過度な設計がなく理解しやすいか | > 8 |
| Maintainability | 他の開発者が拡張・デバッグしやすいか | > 8 |
| Consistency | 既存のプロジェクト規約に準拠しているか | > 8 |

⚠️ **1つでもスコアが8未満なら**、該当ステップに戻って改善 → 最大3回リトライ

---

### 🧪 PRD-Driven Development（PRD駆動開発）

**概要**: Product Requirements Document (PRD) を作成し、それを GitHub Issues として管理するワークフローです。

```
┌─────────────────────────────────────────────────────────────────┐
│                   PRD-Driven Development フロー                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  @prd (Create PRD Agent)                                        │
│         │                                                       │
│         ▼                                                       │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ 1. 要件のヒアリング                                       │  │
│  │    • ターゲットユーザーは？                               │  │
│  │    • 主要機能は？                                         │  │
│  │    • 制約条件は？                                         │  │
│  └──────────────────────────────────────────────────────────┘  │
│         │                                                       │
│         ▼                                                       │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ 2. PRD の生成 (prd.md)                                    │  │
│  │    • Product overview                                     │  │
│  │    • Goals (business / user / non-goals)                  │  │
│  │    • User personas                                        │  │
│  │    • Functional requirements                              │  │
│  │    • User stories + Acceptance criteria                   │  │
│  │    • Technical considerations                             │  │
│  │    • Milestones & sequencing                              │  │
│  └──────────────────────────────────────────────────────────┘  │
│         │                                                       │
│         ▼                                                       │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ 3. ユーザー承認後                                         │  │
│  │    → GitHub Issues を自動作成                             │  │
│  │    → 各 User Story が個別の Issue に                       │  │
│  │    → 優先度・見積もり・依存関係を含む                      │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**使用例**:
```bash
@prd 検索フィルター機能の PRD を作成して
```

---

### 🔄 Context7 との連携ワークフロー

**概要**: Context7 MCP を使って最新のライブラリドキュメントを取得し、常に最新のベストプラクティスでコーディングします。

```
┌─────────────────────────────────────────────────────────────────┐
│                   Context7 ワークフロー                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  📋 質問例: 「React hooks の使い方は？」                         │
│                                                                 │
│  1️⃣ ライブラリ ID を解決                                        │
│     mcp_context7_resolve-library-id({ libraryName: "react" })   │
│     → /facebook/react を選択                                    │
│                                                                 │
│  2️⃣ package.json で現在のバージョンを確認                       │
│     → "react": "^18.3.1"                                        │
│                                                                 │
│  3️⃣ 最新バージョンを確認                                        │
│     npm registry または Context7 の Versions フィールド         │
│     → Latest: 19.0.0                                            │
│                                                                 │
│  4️⃣ 両方のバージョンのドキュメントを取得                        │
│     get-library-docs({ id: "/facebook/react", topic: "hooks" }) │
│                                                                 │
│  5️⃣ 回答とアップグレードガイダンス                              │
│     ├── 現在バージョンでの使い方                                │
│     ├── 最新バージョンでの変更点                                │
│     ├── Breaking changes                                        │
│     └── 移行推奨度                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Context7 エージェントの使用例**:
```bash
# 最新のドキュメントを取得
@context7 Next.js の Server Actions について教えて

# バージョンアップガイダンス
@context7 React 18 から 19 へのアップグレード方法は？

# 特定トピックの詳細
@context7 Tailwind CSS のダークモード実装のベストプラクティスは？
```

---

### 🎯 Software Engineering Team Collection

awesome-copilot には**7人の専門家チーム**が用意されています。それぞれが開発ライフサイクルの特定フェーズを担当します。

```
┌─────────────────────────────────────────────────────────────────┐
│           Software Engineering Team (7 Specialists)              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐          │
│  │ se-ux-ui-  │   │ se-product- │   │ se-system-  │          │
│  │ designer   │   │ manager-    │   │ architecture│          │
│  │            │   │ advisor     │   │ -reviewer   │          │
│  │ UX 分析    │   │ Issue 作成 │   │ アーキ評価 │          │
│  │ JTBD 分析  │   │ 要件整理   │   │ スケーラ   │          │
│  │            │   │            │   │ ビリティ   │          │
│  └─────────────┘   └─────────────┘   └─────────────┘          │
│                                                                 │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐          │
│  │ se-security│   │ se-gitops-  │   │ se-technical│          │
│  │ -reviewer  │   │ ci-specialist│   │ -writer    │          │
│  │            │   │             │   │            │          │
│  │ OWASP      │   │ CI/CD       │   │ ドキュメント│          │
│  │ Zero Trust │   │ デプロイ   │   │ ブログ執筆 │          │
│  │ LLM セキュ │   │ GitOps     │   │ チュートリ │          │
│  │ リティ     │   │             │   │ アル       │          │
│  └─────────────┘   └─────────────┘   └─────────────┘          │
│                                                                 │
│  ┌─────────────┐                                               │
│  │ se-responsi│                                               │
│  │ ble-ai     │                                               │
│  │            │                                               │
│  │ バイアス防止│                                               │
│  │ プライバシー│                                               │
│  │ 倫理的 AI  │                                               │
│  └─────────────┘                                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**チーム連携ワークフロー例**:
```bash
# Step 1: UX 分析
@se-ux-ui-designer 検索機能のユーザージャーニーを分析して

# Step 2: Issue 作成
@se-product-manager-advisor 分析結果を GitHub Issue として作成して

# Step 3: アーキテクチャレビュー
@se-system-architecture-reviewer 提案された設計をレビューして

# Step 4: 実装後のセキュリティレビュー
@se-security-reviewer 実装したコードのセキュリティをチェックして

# Step 5: ドキュメント作成
@se-technical-writer この機能の技術ドキュメントを作成して
```

---

### 📦 awesome-copilot Collections（おすすめコレクション）

awesome-copilot には目的別にまとめられた**コレクション**があります。このプロジェクトに特に関連するものを紹介します。

| コレクション | 説明 | 主なエージェント・プロンプト |
|------------|------|---------------------------|
| **project-planning** | プロジェクト計画・管理 | task-planner, task-researcher, prd, implementation-plan |
| **testing-automation** | テスト自動化・TDD | tdd-red, tdd-green, tdd-refactor, playwright-tester |
| **software-engineering-team** | 7人の専門家チーム | se-* 系エージェント7種 |
| **security-best-practices** | セキュリティ・品質 | security-and-owasp, a11y, performance-optimization |
| **frontend-web-dev** | フロントエンド開発 | expert-react-frontend-engineer, nextjs.instructions |

**コレクションのインストール**:
```bash
# awesome-copilot リポジトリからコレクションをダウンロード
# https://github.com/github/awesome-copilot/tree/main/collections
```

---

### ⚡ ベストプラクティス・Tips

#### 1. エージェント選択の原則

```
┌─────────────────────────────────────────────────────────────────┐
│                エージェント選択のゴールデンルール                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  🎯 タスクの複雑さで選ぶ:                                        │
│     • 単純なコード変更 → expert-nextjs-developer                │
│     • 複雑なマルチファイル → blueprint-mode                      │
│     • 大規模リファクタ → task-planner + task-researcher          │
│                                                                 │
│  📋 フェーズで選ぶ:                                              │
│     • 計画フェーズ → plan, specification, prd                   │
│     • 実装フェーズ → blueprint-mode, expert-nextjs-developer     │
│     • レビューフェーズ → wg-code-sentinel, accessibility         │
│                                                                 │
│  🔄 イテレーションで選ぶ:                                        │
│     • 初回 → task-researcher で徹底調査                         │
│     • 計画確定後 → task-planner で実行計画                      │
│     • 実装中 → 新しいチャットで Agent モード                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 2. チャット管理のベストプラクティス

| 状況 | 推奨アクション |
|------|--------------|
| 計画作成後に実装開始 | **新しいチャットを開く**（コンテキスト分離） |
| 長い会話で迷子になった | `@mentor` で現状整理、または新規チャット |
| エラーが解消しない | `@critical-thinking` で前提を検証 |
| ライブラリの使い方が不明 | `@context7` で最新ドキュメント取得 |

#### 3. プロンプトエンジニアリングのコツ

```markdown
# ❌ 悪い例
機能を追加して

# ✅ 良い例
検索フィルター機能を追加して。
- カテゴリでフィルタリング可能
- 入力はリアルタイムでフィルタリング（debounce 300ms）
- Tailwind CSS でスタイリング
- アクセシビリティ: キーボードナビゲーション対応
```

**OpenAI プロンプトエンジニアリングの原則**（Context7 で確認済み）:
1. **具体的に**: 曖昧な指示を避ける
2. **コンテキストを提供**: 関連ファイルや既存パターンを参照
3. **イテレーション**: 結果を見て次の指示を調整
4. **例を示す**: 期待する出力形式を示す

---

## エージェント詳細リファレンス

### 🚀 開発 & 実装

#### expert-nextjs-developer

**概要**: Next.js 16 のエキスパート開発者。App Router、Server Components、Cache Components、Turbopack に精通。

**得意分野**:
- App Router でのルーティング実装
- Server/Client Components の使い分け
- `use cache` ディレクティブによるキャッシュ最適化
- TypeScript での型安全な実装
- React 19.2 の新機能（View Transitions など）

**使用例**:
```
@expert-nextjs-developer Server Action でフォーム送信を実装して
@expert-nextjs-developer 動的メタデータを設定するページを作成して
```

**特徴**:
- **v16 の Breaking Change 対応**: `params` と `searchParams` の async 対応
- コード例には必ずインポート文と型定義を含む
- パフォーマンス最適化のベストプラクティスを提案

---

#### blueprint-mode

**概要**: 構造化されたワークフロー（Debug、Express、Main、Loop）で複雑なタスクを処理。厳密な品質管理と自己修正機能を持つ。

**特徴**:
- **4つのワークフロー**: 
  - Loop: 繰り返しタスク
  - Debug: バグ修正
  - Express: 小規模な変更（2ファイル以下）
  - Main: それ以外の複雑なタスク
- **自己評価**: 5つの基準で1-10のスコアリング（8以上で合格）
- **リトライ**: 失敗時は最大3回まで異なるアプローチで再試行

**使用例**:
```
@blueprint-mode 全ページにパンくずリストを追加して
@blueprint-mode このバグを修正して
```

---

#### playwright-tester

**概要**: Playwright を使った E2E テストの専門家。ユーザー視点で信頼性の高いテストを作成。

**得意分野**:
- ユーザーフローのテスト作成
- 強いセレクター（`getByRole`, `getByLabel`）の使用
- テストの独立性と信頼性の確保
- Page Object Model の実装

**使用例**:
```
@playwright-tester ログインフローの E2E テストを作成して
@playwright-tester カタログページのナビゲーションテストを書いて
```

---

### 📋 計画 & 設計

#### plan (Plan Mode)

**概要**: 戦略的な計画とアーキテクチャ分析を行うアシスタント。**コード編集は行わない**。

**特徴**:
- コードベースを探索して既存パターンを理解
- 要件を明確化し、複数のアプローチを提案
- リスク評価と代替案の検討

**使用例**:
```
@plan ダークモードの実装方法を検討して
@plan このコードベースのアーキテクチャを分析して
```

---

#### specification

**概要**: 仕様書を生成・更新するエージェント。AI が理解しやすい構造化されたドキュメントを作成。

**出力形式**:
- 要件、制約、ガイドラインのリスト（REQ-001, CON-001 など）
- インターフェースとデータ契約
- 受け入れ基準（Given-When-Then 形式）
- テスト自動化戦略

**使用例**:
```
@specification 検索フィルター機能の仕様書を作成して
@specification 既存の認証フローの仕様をドキュメント化して
```

---

#### task-researcher

**概要**: 実装前の深い調査を行う専門家。コードベースと外部ドキュメントを徹底的に調査し、調査レポートを生成。**コード編集は行わない**。

**特徴**:
- **調査のみに特化**: ソースコードや設定ファイルの変更は一切行わない
- **複数ソースの調査**: コードベース、GitHub リポジトリ、公式ドキュメントを横断的に調査
- **代替案の評価**: 複数の実装アプローチを調査し、比較・評価

**出力ファイル**: `.copilot-tracking/research/YYYYMMDD-task-description-research.md`

**調査内容**:
- プロジェクト構造と既存パターンの分析
- 実装パターンとコード例
- API・スキーマドキュメント
- 外部ライブラリの調査
- 推奨アプローチの提案

**使用例**:
```
@task-researcher Next.js 16 の Server Actions について調査して
@task-researcher shadcn/ui の DataTable コンポーネントの実装パターンを調査して
```

**task-planner との連携**:
```
# Step 1: まず調査
@task-researcher 検索フィルター機能の実装方法を調査して

# Step 2: 調査結果を基に計画
@task-planner #file:.copilot-tracking/research/20260115-search-filter-research.md
この調査結果を基に実装計画を作成して
```

---

#### task-planner

**概要**: 調査に基づいた実行可能なタスク計画を作成するエージェント。microsoft/edge-ai が開発。

**特徴**:
- **3ファイル生成**: Plan（チェックリスト）、Details（詳細）、Prompt（実行用）
- **調査必須**: 計画作成前に必ず調査ファイルの存在を確認
- **行番号参照**: ファイル間の正確な行番号参照を維持

**出力ファイル**:
| ファイル | 配置場所 | 内容 |
|---------|---------|------|
| Plan | `.copilot-tracking/plans/*-plan.instructions.md` | フェーズとタスクのチェックリスト |
| Details | `.copilot-tracking/details/*-details.md` | 各タスクの詳細な実装仕様 |
| Prompt | `.copilot-tracking/prompts/implement-*.prompt.md` | 実装を実行するためのプロンプト |

**使用例**:
```
@task-planner カタログページに検索フィルター機能を追加したい
@task-planner Server Actions でフォーム送信機能を実装したい
```

**実装の実行**（計画作成後）:
```bash
# 1. 新しいチャットを開く
# 2. Agent モードに切り替え
# 3. 生成されたプロンプトを実行
#file:.copilot-tracking/prompts/implement-search-filter.prompt.md
```

**制御オプション**:
- `phaseStop=true` - 各フェーズ完了後に停止（デフォルト）
- `phaseStop=false` - 全フェーズを一気に実装
- `taskStop=true` - 各タスク完了後に停止

---

#### arch (Senior Cloud Architect)

**概要**: クラウドアーキテクト。アーキテクチャ図とドキュメントを Mermaid で作成。**コードは生成しない**。

**作成する図**:
1. システムコンテキスト図
2. コンポーネント図
3. デプロイメント図
4. データフロー図
5. シーケンス図

**使用例**:
```
@arch このシステムのアーキテクチャ図を作成して
@arch マイクロサービス構成を設計して
```

---

### 🧪 テスト & 品質

#### tdd-red / tdd-green / tdd-refactor

**概要**: TDD の3フェーズをそれぞれ専門的にサポートするエージェント群。

| フェーズ | エージェント | 役割 |
|---------|------------|------|
| 🔴 Red | tdd-red | 失敗するテストを書く（要件を定義） |
| 🟢 Green | tdd-green | テストを通す最小限のコードを書く |
| 🔵 Refactor | tdd-refactor | テストを緑に保ちながら設計を改善 |

**使用例**:
```
# Step 1: Red
@tdd-red ユーザー認証機能のテストを書いて

# Step 2: Green
@tdd-green このテストを通すコードを書いて

# Step 3: Refactor
@tdd-refactor このコードをリファクタリングして
```

---

### 🔐 セキュリティ & レビュー

#### wg-code-sentinel

**概要**: セキュリティレビューの専門家。JARVIS（アイアンマン）のような丁寧で知的なコミュニケーションスタイル。

**チェック項目**:
- 入力バリデーション（SQL インジェクション、XSS、コマンドインジェクション）
- 認証・認可
- データ保護（暗号化、PII 処理）
- シークレット管理
- 依存関係の脆弱性

**使用例**:
```
@wg-code-sentinel このフォーム処理のセキュリティをレビューして
@wg-code-sentinel API ルートのセキュリティを確認して
```

---

#### wg-code-alchemist

**概要**: Clean Code と SOLID 原則の専門家。JARVIS のようなスタイルで丁寧にコード改善を提案。

**適用する原則**:
- SOLID 原則
- DRY（Don't Repeat Yourself）
- KISS（Keep It Simple, Stupid）
- YAGNI（You Aren't Gonna Need It）

**使用例**:
```
@wg-code-alchemist この関数を Clean Code にリファクタして
@wg-code-alchemist このクラスの SOLID 違反を指摘して
```

---

#### gilfoyle

**概要**: シリコンバレー（ドラマ）の Gilfoyle のキャラクター。辛辣だが的確な技術的批評を行う。**コード修正は行わない**。

**特徴**:
- 遠慮のない批評
- 実際に技術的に正確
- 解決策は教えない（自分で考えさせる）
- 学習効果が高い（厳しいフィードバックから学ぶ）

**使用例**:
```
@gilfoyle このコードをレビューして
```

⚠️ **注意**: 初心者には心理的に厳しい場合があります。自信がついてから使うことを推奨。

---

#### accessibility

**概要**: WCAG 2.2 Level AA 準拠のアクセシビリティ専門家。

**チェック項目**:
- セマンティック HTML
- キーボードナビゲーション
- ARIA 属性
- カラーコントラスト
- スクリーンリーダー対応
- フォーカス管理

**使用例**:
```
@accessibility このフォームのアクセシビリティを監査して
@accessibility モーダルダイアログのキーボード操作を確認して
```

---

### 📚 ドキュメント & 学習

#### context7

**概要**: Context7 MCP を使って最新のライブラリドキュメントを取得する専門家。

**機能**:
- ライブラリ名から Context7 ID を解決
- 特定トピックのドキュメントを取得
- プロジェクトのバージョンと最新バージョンの比較
- アップグレード提案

**使用例**:
```
@context7 Vitest のモック機能について教えて
@context7 shadcn/ui の Dialog コンポーネントの使い方
```

---

#### se-technical-writer

**概要**: 開発者ドキュメント、技術ブログ、チュートリアルを作成する専門家。

**対応コンテンツ**:
- 技術ブログ記事
- API ドキュメント
- チュートリアル
- アーキテクチャドキュメント

**使用例**:
```
@se-technical-writer この機能の使い方ドキュメントを書いて
@se-technical-writer Server Components についてのブログ記事を書いて
```

---

### 🎓 メンタリング & 教育

#### mentor

**概要**: メンターとして質問やヒントを通じて学習を支援。**コード編集は行わない**。

**アプローチ**:
- ソクラテス式の質問
- 5 Whys テクニック
- 安全でないプラクティスの指摘
- 長期的なコストの説明

**使用例**:
```
@mentor この実装アプローチについてアドバイスが欲しい
@mentor なぜこの設計が良くないのか教えて
```

---

#### critical-thinking

**概要**: 批判的思考を促すエージェント。「なぜ？」を問い続けて前提を検証する。**コード編集は行わない**。

**特徴**:
- 一度に1つの質問のみ
- 解決策は提案しない
- 前提への挑戦
- 代替案の探索を促す

**使用例**:
```
@critical-thinking この設計の前提を検証したい
@critical-thinking なぜ Server Components を選んだのか？
```

---

#### demonstrate-understanding

**概要**: 理解度を質問で検証するエージェント。**コード編集は行わない**。

**プロセス**:
1. ユーザーに説明を求める
2. 説明の gaps や誤解を特定
3. フォローアップの質問
4. 正しい理解に導く

**使用例**:
```
@demonstrate-understanding React Server Components について説明して
@demonstrate-understanding この認証フローを説明してみて
```

---

## 参考リンク

- [awesome-copilot リポジトリ](https://github.com/github/awesome-copilot) - エージェント定義の元ソース
- [Instructions ガイド](./INSTRUCTIONS_GUIDE.md) - Instructions の詳細な使い方
- [Prompts ガイド](./PROMPTS_GUIDE.md) - 再利用可能な Prompt の使い方
- [GitHub Copilot カスタマイズガイド](./COPILOT_CUSTOMIZATION_GUIDE.md) - このプロジェクトでのカスタマイズ
- [shadcn/ui ガイド](./SHADCN_GUIDE.md) - UI コンポーネントの使い方
- [改善ロードマップ](./IMPROVEMENT_ROADMAP.md) - プロジェクトの今後の計画

---

## 付録: 全エージェント一覧

| エージェント | カテゴリ | コード編集 | 主な用途 |
|------------|--------|----------|---------|
| accessibility | レビュー | ✅ | アクセシビリティ監査 |
| address-comments | 開発 | ✅ | PR コメント対応 |
| arch | 設計 | ❌ | アーキテクチャ図作成 |
| blueprint-mode | 開発 | ✅ | 構造化ワークフローで開発 |
| context7 | ドキュメント | ❌ | ライブラリドキュメント取得 |
| critical-thinking | 教育 | ❌ | 批判的思考促進 |
| custom-agent-foundry | ユーティリティ | ✅ | エージェント作成 |
| demonstrate-understanding | 教育 | ❌ | 理解度確認 |
| devops-expert | DevOps | ✅ | CI/CD パイプライン設計 |
| expert-nextjs-developer | 開発 | ✅ | Next.js 開発 |
| gilfoyle | レビュー | ❌ | 辛辣なコードレビュー |
| github-actions-expert | DevOps | ✅ | GitHub Actions |
| hlbpa | 設計 | ✅ | 高レベル設計・ドキュメント |
| implementation-plan | 計画 | ✅ | 詳細な実装計画 |
| janitor | リファクタ | ✅ | 不要コード削除 |
| mentor | 教育 | ❌ | メンタリング |
| modernization | リファクタ | ✅ | モダナイゼーション |
| plan | 計画 | ❌ | 戦略的計画 |
| planner | 計画 | ❌ | シンプルな実装計画 |
| playwright-tester | テスト | ✅ | E2E テスト作成 |
| prompt-builder | ユーティリティ | ✅ | プロンプト構築 |
| prompt-engineer | ユーティリティ | ❌ | プロンプト改善 |
| refine-issue | 計画 | ✅ | Issue 詳細化 |
| research-technical-spike | 計画 | ❌ | 技術調査 |
| se-gitops-ci-specialist | DevOps | ✅ | GitOps/CI 専門 |
| se-product-manager-advisor | アイデア | ✅ | PM アドバイス |
| se-responsible-ai | レビュー | ✅ | 責任ある AI |
| se-security-reviewer | レビュー | ✅ | セキュリティレビュー |
| se-system-architecture-reviewer | 設計 | ✅ | アーキテクチャレビュー |
| se-technical-writer | ドキュメント | ✅ | 技術文書作成 |
| se-ux-ui-designer | アイデア | ✅ | UX 分析 |
| simple-app-idea-generator | アイデア | ❌ | アイデア生成 |
| specification | 計画 | ✅ | 仕様書作成 |
| task-planner | 計画 | ✅ | タスク計画 |
| task-researcher | 計画 | ✅ | タスク調査 |
| tdd-green | テスト | ✅ | TDD Green フェーズ |
| tdd-red | テスト | ✅ | TDD Red フェーズ |
| tdd-refactor | テスト | ✅ | TDD Refactor フェーズ |
| tech-debt-remediation-plan | リファクタ | ✅ | 技術的負債対策 |
| technical-content-evaluator | ドキュメント | ✅ | コンテンツ評価 |
| wg-code-alchemist | レビュー | ✅ | Clean Code レビュー |
| wg-code-sentinel | レビュー | ✅ | セキュリティレビュー |

---

*このドキュメントは学習者向けに作成されています。各エージェントを試して、自分のワークフローに最適なものを見つけてください！*
